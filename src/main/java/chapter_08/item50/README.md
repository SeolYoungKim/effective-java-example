# 적시에 방어적 복사본을 만들라 
> 클라이언트가 불변식을 깨뜨리려 혈안이 되어있다고 가정하고 방어적으로 프로그래밍 하라 

- 어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하게 구성해야 한다. 
- 내가 클래스를 아무리 불변으로 꾸며놔도, `Date`같은 가변 클래스를 이용해버리면 그건 가변 클래스가 된다.
  - `Instant`, `LocalDateTime` 등 불변 클래스를 이용하자.
  - `Date`는 낡은 API이니, 새로운 코드를 작성할 때는 더 이상 사용하지 말것 

## 예전에 작성된 낡은 코드들은 어떻게 대처할까?
- 가변 매개변수 각각을 방어적으로 복사해서 사용하라.
- 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사하자. 
  - 멀티 스레딩 환경이라면, 원본 객체의 유효성을 검사한 후 복사본을 만들게 될 경우, 찰나의 취약한 순간에 원본 객체를 수정할 위험성이 있기 때문!
  - 그러니 반드시 위와 같은 순서로 하자. 

### 방어적 복사본을 만들 때 `clone`을 주의하라 
- `Date`는 final 클래스가 아니다. 즉, `clone` 메서드는 `Date`가 정의한 것이 아닐 가능성이 있다.
  - `clone`이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다는 뜻이다.
- 매개변수가 제 3자에 의해 확장될 수 있는 타입일 경우, 방어적 복사본을 만들 때 `clone`을 사용해서는 안된다!

### getter도 주의해야 한다.
- 접근자 메서드가 가변 객체를 그대로 반환할 경우, 클래스 필드를 변경할 수 있게 된다. 
- 따라서, 가변 필드에 대한 getter와 같은 접근자 메서드를 제공할 때도, **방어적 복사본**을 반환하도록 하라


### 되도록 불변 객체들을 조합해 객체를 구성하자 
- 그래야 방어적 복사를 할 일이 줄어든다. 
- 방어적 복사에는 성능 저하가 따르고, 항상 쓸 수 있는 것도 아니다.

### 방어적 복사를 생략해도 되는 상황 
- 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때 
- 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때 
  - 예 : 래퍼 클래스 
# Serializable을 구현할지는 신중히 결정하라 
## Serializable
- 어떤 클래스의 인스턴스를 직렬화할 수 있게 만들 수 있음 
- 쉬워 보이지만, 사실은 값비싼 일이다. 

## Serializable을 구현하면 릴리스 후 수정이 어렵다.
- 직렬화된 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 API가 되어버림 
  - 그러니 직렬화된 형태도 영원히 지원해야 하는 일이 발생한다. 
  - 커스텀 직렬화 형태를 설계하지 않고 자바의 기본 방식을 사용하면, 직렬화 형태는 최소 적용 당시 클래스의 내부 구현 방식에 영원히 묶여버린다.
  - 즉, 기본 직렬화 형태에서는 클래스의 `private`과 `package-private` 인스턴스 필드들마저 API로 공개하는 꼴이 된다.(캡슐화가 깨짐)
- 버전관리도 해줘야함 


> 직렬화 가능 클래스를 만들 경우, 길게 보되 감당할 수 있을 만큼 고품질의 직렬화 형태도 주의해서 함께 설계해야 함


## 직렬화가 클래스 개선을 방해하는 예 
- `static final long serialVersionUID`
- 해당 번호가 명시되지 않을 경우, 시스템이 런타임에 암호 함수(SHA-1)를 적용해 자동으로 클래스 안에 생성해 넣음 
  - 클래스 이름, 구현한 인터페이스들, 컴파일러가 자동으로 생성해 넣은 것을 포함한 대부분의 클래스 멤버들이 고려됨 
  - 그래서 클래스가 조금이라도 수정도리 경우, `serialVersionUID`도 함께 변함 
  - 자동 생성되는 값에 의존할 경우, 쉽게 호환성이 깨져 런타임에 `InvalidClassException`이 발생할 것임 


## 버그와 보안 구멍이 생길 위험이 높아진다.
- 객체는 생성자를 사용해 만드는 것이 기본이다.
- 반면, 직렬화는 언어의 기본 메커니즘을 우회하는 객체 생성 기법이다. 
  - 즉, 역직렬화는 일반 생성자의 문제가 그대로 적용되는 숨은 생성자라고 볼 수 있다.
  - 역직렬화 시, 생성자에서 구축한 불변식을 모두 보장해야 하고 생성 도중 공격자가 객체 내부를 들여다볼 수 없도록 해야하는데, 이를 떠올리기가 어려워진다. 
- 결론적으로 **역직렬화를 사용하면 불변식 깨짐과 함께 허가되지 않은 접근에 쉽게 노출된다.**


## 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.
- 직렬화 가능 클래스가 수정될 경우, 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지, 그 반대도 가능한지 검사해야 함 
- 이에 따라, 테스트할 양이 증가한다는 문제 발생 


## Serializable 구현 여부는 가볍게 결정할 사안이 아니다.
- 단, 객체를 전송하거나 저장할 때 자바 직렬화를 이용하는 프레임워크용으로 만든 클래스인 경우,
  - Serializable을 반드시 구현해야 하는 다른 클래스의 컴포넌트로 쓰일 경우 등에는 어쩔 수 없음
- Serializable 구현에 따르는 비용은 적지 않다.
  - 클래스 설계 시 그 이득과 비용을 적절히 트레이드오프 해야 한다. 
  - BigInteger, Instant와 같은 "값 클래스"와 "컬렉션 클래스"들은 Serializable을 구현함
  - 스레드 풀과 같이 "동작하는 객체"를 표현하는 클래스들은 대부분 Serializable을 구현하지 않음 


## 상속용으로 설계된 클래스, 인터페이스는 대부분 Serializable을 구현하면 안된다.
- 클래스를 확장하거나, 인터페이스를 구현하는 사용자에게 커다란 부담을 지우게 될 것이다.
- 상속용 클래스 중 `Serializable`을 구현한 예로는 `Throwable`, `Component`가 있음 
  - `Throwable`은 서버가 RMI를 통해 클라이언트로 예외를 보내기 위한 목적으로 Serializable을 구현함 
  - `Component`는 GUI를 전송하고, 저장하고, 복원하기 위해 Serializable을 구현함 


## 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능한 경우 
- 인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 반드시 하위 클래스에서 `finalize`를 재정의하지 못하게 해야 함 (final로 선언)
  - `finalizer` 공격 방지
- 인스턴스 필드 중 기본값(int=0, boolean=false, reference=null)으로 초기화되면 위배되는 불변식이 있을 경우, 클래스에 다음의 `readObjectNoData` 메서드를 반드시 추가해야 함 

```java
private void readObjectNoData() throws InvalidObjectException {
    throw new InvalidObjectException("스트림 데이터가 필요합니다.");
}
```
- 자바 4에 추가된 기능 
- 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 경우를 위한 메서드 


## Serializable을 구현하지 않기로 했을 경우 
- 상속용 클래스의 경우, 직렬화를 지원하지 않으면 그 하위 클래스가 직렬화를 지원하려 할 때 부담이 증가함 
- 보통 이와 같은 클래스를 역직렬화 할 경우, 그 상위 클래스는 매개변수가 없는 생성자를 제공해야 함 
  - 이러한 생성자를 제공하지 안ㄴㅎ으면, 직렬화 프록시 패턴을 사용해야 함 


## 내부 클래스는 직렬화를 구현하지 말아야 함 
- 내부 클래스에는 바깥 인스턴스의 참조와 유효 범위 안의 지역변수 값들을 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가됨 
  - 내부 클래스에 대한 기본 직렬화 형태는 분명하지 않다.
  - 단, 내부 `static class`는 `Serializable`을 구현해도 된다.


## 정리 
- 한 클래스의 여러 버전이 상호작용할 일이 없고, 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등, 보호된 환경에만 쓰일 클래스가 아니라면 `Serializable`의 구현은 아주 신중하게 이뤄져야 한다. 
- 상속할 수 있는 클래스일 경우 주의사항이 훨씬 더 많아진다.





# 마커 인터페이스
- `Serializable`인터페이스가 가장 좋은 마커 인터페이스의 예시
  - 자신을 구현한 클래스의 인스턴스는 `ObjectOutputStream`을 통해 쓸(write)수 있다고, 직렬화 할 수 있다고 알려줌.

# 마커 인터페이스의 장점
- 마커 인터페이스는 두 가지 측면에서 마커 애너테이션보다 낫다.
  - 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있다.
    - 어엿한 타입이다. 컴파일 타임에 오류를 잡을 수 있다.
  - 마커 애너테이션은 그럴 수 없다.
    - 런타임에야 오류를 발견할 수 있다.

- 자바의 직렬화는 `Serializable`마커 인터페이스를 보고 그 대상이 직렬화 할 수 있는 타입인지를 확인한다.
```java
ObjectOutputStream.writeObject
```
- 위 메서드는 당연히 인수로 받은 객체가 `Serializable`을 구현했을 거라고 가정한다.
  - 하지만, 이 메서드는 `Serializable`이 아닌 `Object`객체를 받도록 설계되었다.
  - 직렬화 할 수 없는 객체를 넘긴다 하더라도, 런타임에야 문제를 확인할 수 있게 된다.
  - 마커 인터페이스를 사용하는 주 이유가 컴파일 타임 오류 검출이나, 그 이점을 살리지 못한 케이스다.

- 마커 인터페이스는 적용 대상을 더 정밀하게 지정할 수 있다.
  - 애너테이션은 부착 가능한 타입을 더 세밀하게 제한할 수 없다. 
    - `@Target(ElementType.TYPE)`으로 선언한 애너테이션은 모든 타입, 즉 클래스, 인터페이스, 열거 타입, 애너테이션에 달 수 있다.
  - 특정 인터페이스를 구현한 클래스에만 적용하고 싶은 마커가 있다면 ?
    - 마커를 인터페이스로 정의하라. 
    - 마킹하고 싶은 클래스에서만 인터페이스를 구현하면 된다.
  - 가장 좋은 예시 `Set`
    - Collection의 하위 타입에만 적용할 수 있음
    - Collection이 정의한 메서드 외에는 새로 추가한 것이 없음
    - 특정 인터페이스의 하위 타입에만 적용할 수 있기 때문에 마커 인터페이스로써의 역할을 잘 하고 있따.

- 마커 인터페이스는
  - 객체의 특정 부분을 불변식으로 규정하거나, 그 타입의 인스턴스는 다른 클래스의 특정 메서드가 처리할 수 있따는 사실을 명시하는 용도로 사용할 수 있을 것임.
  - `Serializable`인터페이스가 `ObjectOutputStream`이 처리할 수 있는 인스턴스임을 명시하는 것이 바로 위의 예시다.


# 마커 애너테이션의 장점
- 거대한 애너테이션 시스템의 지원을 받을 수 있다.
- 애너테이션을 적극 활용하는 프레임워크에서는, 마커 애너테이션을 쓰는 쪽이 일관성을 지키는 데 유리하다.


# 그럼 어디에 뭘쓸까
- 클래스와 인터페이스 외의 프로그램 요소에 마킹한다(모듈, 패키지, 필드, 지역변수 등) -> 애너테이션
  - 클래스와 인터페이스만이 인터페이스를 구현하거나 확장할 수 있기 때문
- 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있다 -> 인터페이스